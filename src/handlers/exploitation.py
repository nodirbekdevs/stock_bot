from datetime import datetime

from aiogram.dispatcher import FSMContext
from aiogram.types import CallbackQuery, Message
from bson import ObjectId

from src.loader import dp, bot
from src.models import Admin, Product, Exploitation, ExploitationItem
from src.controllers import admin_controller, product_controller, exploitation_controller, exploitation_items_controller
from src.helpers.keyboards import (
    exploitation_keyboard,
    back_keyboard,
    one_exploitation_product_keyboard,
    confirmation_exploitation_keyboard,
    one_using_exploitation_keyboard
)
from src.helpers.utils import Pagination, is_num
from src.helpers.format import product_format, exploitation_format, confirmation_exploitation_format
from src.states.exploitation import ExploitationStates


@dp.callback_query_handler(lambda query: query.data == "products", state=ExploitationStates.process)
async def exploitation_all_products_handler(query: CallbackQuery, state: FSMContext):
    pagination = Pagination(data_type="PRODUCTS")
    paginated = await pagination.paginate(query={}, page=1, limit=6)
    await ExploitationStates.all_products.set()
    await query.message.edit_text(text=paginated['message'], reply_markup=paginated['keyboard'])


@dp.callback_query_handler(lambda query: query.data == "back", state=ExploitationStates.all_products)
async def back_from_exploitation_all_products_handler(query: CallbackQuery, state: FSMContext):
    await ExploitationStates.process.set()
    await query.message.edit_text(text="Страница эксплуатации", reply_markup=exploitation_keyboard())


@dp.callback_query_handler(lambda query: query.data == "delete", state=ExploitationStates.all_products)
async def back_from_exploitation_all_products_handler(query: CallbackQuery, state: FSMContext):
    await ExploitationStates.process.set()
    await query.message.edit_text(text="Страница эксплуатации", reply_markup=exploitation_keyboard())


@dp.callback_query_handler(lambda query: query.data in ["left#products#", "right#products#"], state=ExploitationStates.all_products)
async def pagination_exploitation_products_handler(query: CallbackQuery, state: FSMContext):
    pagination = Pagination(data_type="PRODUCTS")
    paginated = await pagination.paginate(query={}, page=int(query.data.split("#")[2]), limit=6)
    await query.message.edit_text(text=paginated['message'], reply_markup=paginated['keyboard'])


@dp.callback_query_handler(lambda query: query.data.startswith("sproduct_"), state=ExploitationStates.all_products)
async def get_exploitation_product_handler(query: CallbackQuery, state: FSMContext):
    print(query.data)

    id = query.data.split("_")[1]

    product = await product_controller.get_one({"_id": ObjectId(id)})

    print(product)

    await ExploitationStates.one_product.set()

    await query.message.edit_text(text=product_format(product), reply_markup=one_exploitation_product_keyboard(id))


@dp.callback_query_handler(lambda query: query.data == "back", state=ExploitationStates.one_product)
async def back_from_get_product_handler(query: CallbackQuery, state: FSMContext):
    pagination = Pagination(data_type="PRODUCTS")
    paginated = await pagination.paginate(query={}, page=1, limit=6)
    await ExploitationStates.all_products.set()
    await query.message.edit_text(text=paginated['message'], reply_markup=paginated['keyboard'])


@dp.callback_query_handler(lambda query: query.data.startswith("add_use.product."), state=ExploitationStates.one_product)
async def set_exploitation_product_handler(query: CallbackQuery, state: FSMContext):
    id = query.data.split(".")[2]

    # message_for_delete = (await state.get_data())['message_for_delete']

    admin: Admin = await admin_controller.get_one({"admin_id": query.from_user.id})

    exploitation: Exploitation = await exploitation_controller.get_one({"status": "process"})

    if exploitation is None:
        new_exploitation = await exploitation_controller.make({"admin": admin['first_name']})
        exploitation: Exploitation = await exploitation_controller.get_one({"_id": new_exploitation.inserted_id})

    product = await product_controller.get_one({"_id": ObjectId(id)})

    if product['_id'] in exploitation['products']:
        await query.message.answer(text="Вы уже добавили эту технику для начинания эксплуатации")
        return

    data = dict(exploitation_id=exploitation['_id'], admin=admin['first_name'], product_name=product['name'])

    print(data)

    exploitation_item_id = await exploitation_items_controller.make(data)

    # exploitation_item = await exploitation_items_controller.get_one({"_id": })

    await exploitation_controller.update_append_list(
        {"_id": exploitation['_id']},
        {"products": exploitation_item_id.inserted_id}
    )

    await ExploitationStates.items.set()

    await query.message.edit_text(text=f"Сколько {product['name']} берется в пользование")


@dp.message_handler(state=ExploitationStates.items)
async def set_product_number_of_exploitation_handler(message: Message, state: FSMContext):
    quantity = message.text

    if not is_num(quantity):
        await message.answer(text="Отправьте правильный число")
        return

    message_id_for_delete = (await state.get_data())['message_for_delete']

    exploitation = await exploitation_controller.get_one({"status": "process"})

    item: ExploitationItem = await exploitation_items_controller.get_one({"status": "process"})

    product: Product = await product_controller.get_one({"name": item['product_name']})

    print(product)
    print(product['count'] < int(quantity) and product['not_in_use'] < int(quantity))

    if product['count'] < int(quantity) or product['not_in_use'] < int(quantity):
        await message.answer(text=f"{quantity} {product['name']} недоступны для использования на складе")
        return

    await exploitation_items_controller.update(
        {"exploitation_id": exploitation['_id'], "product_name": product['name'], "status": "process"},
        {"quantity": int(quantity), "status": "added"}
    )

    await message.delete()
    await bot.delete_message(chat_id=message.from_user.id, message_id=message_id_for_delete)

    await ExploitationStates.process.set()

    message_for_delete = await message.answer("Техника добавлено для использовании", reply_markup=exploitation_keyboard())

    async with state.proxy() as data:
        data['message_for_delete'] = message_for_delete.message_id


@dp.callback_query_handler(lambda query: query.data == "confirmation_products", state=ExploitationStates.process)
async def get_name_for_confirm_exploitation_handler(query: CallbackQuery, state: FSMContext):

    exploitation = await exploitation_controller.get_one({"status": 'process'})

    if exploitation is None:
        await query.message.edit_text(
            text="Ничего не было добавлено, чтобы дать еще",
            reply_markup=exploitation_keyboard()
        )
        return

    exploitation_items = await exploitation_items_controller.get_all(
        {"exploitation_id": exploitation['_id'], "status": "added"}
    )

    await query.message.edit_text(
        text=confirmation_exploitation_format(exploitation, exploitation_items),
        reply_markup=confirmation_exploitation_keyboard(exploitation_items)
    )


@dp.callback_query_handler(lambda query: query.data.startswith("minus.product."), state=ExploitationStates.process)
async def get_name_for_confirm_exploitation_handler(query: CallbackQuery, state: FSMContext):
    id = query.data.split(".")[2]

    exploitation_item = await exploitation_items_controller.get_one({"_id": ObjectId(id)})

    if exploitation_item['quantity'] - 1 == 0:
        await exploitation_controller.update_remove_list(
            {"status": "process"},
            {"products": exploitation_item['_id']}
        )

        await exploitation_items_controller.delete({"_id": exploitation_item['_id']})

    exploitation = await exploitation_controller.get_one({"status": 'process'})

    if len(exploitation['products']) == 0:
        await exploitation_controller.delete({"_id": exploitation['_id']})

        await query.message.edit_text(
            text="Сервис был отключен, потому что больше нечего было давать",
            reply_markup=exploitation_keyboard()
        )
        return

    await exploitation_items_controller.increment({"_id": exploitation_item['_id']}, {"quantity": -1})

    exploitation_items = await exploitation_items_controller.get_all(
        {"exploitation_id": exploitation['_id'], "status": "added"}
    )

    await query.message.edit_text(
        text=confirmation_exploitation_format(exploitation, exploitation_items),
        reply_markup=confirmation_exploitation_keyboard(exploitation_items)
    )


@dp.callback_query_handler(lambda query: query.data.startswith("delete.exp_product."), state=ExploitationStates.process)
async def get_name_for_confirm_exploitation_handler(query: CallbackQuery, state: FSMContext):
    id = query.data.split(".")[2]

    exploitation_item = await exploitation_items_controller.get_one({"_id": ObjectId(id)})

    await exploitation_controller.update_remove_list(
        {"status": "process"},
        {"products": exploitation_item['_id']}
    )

    await exploitation_items_controller.delete({"_id": exploitation_item['_id']})

    exploitation = await exploitation_controller.get_one({"status": 'process'})

    print(exploitation)

    if len(exploitation['products']) == 0:
        await exploitation_controller.delete({"_id": exploitation['_id']})

        await query.message.edit_text(
            text="Сервис был отключен, потому что больше нечего было давать",
            reply_markup=exploitation_keyboard()
        )
        return

    exploitation_items = await exploitation_items_controller.get_all(
        {"exploitation_id": exploitation['_id'], "status": "added"}
    )

    await query.message.edit_text(
        text=confirmation_exploitation_format(exploitation, exploitation_items),
        reply_markup=confirmation_exploitation_keyboard(exploitation_items)
    )

    # message_for_delete = (await state.get_data())['message_for_delete']

    # await bot.delete_message(chat_id=query.from_user.id, message_id=message_for_delete)
    #
    # message_for_delete = await bot.send_message(
    #     chat_id=query.from_user.id,
    #     text=confirmation_exploitation_format(exploitation, exploitation_items),
    #     reply_markup=confirmation_exploitation_keyboard(exploitation_items)
    # )
    #
    # async with state.proxy() as data:
    #     data['message_for_delete'] = message_for_delete.message_id


@dp.callback_query_handler(lambda query: query.data.startswith("plus.product."), state=ExploitationStates.process)
async def get_name_for_confirm_exploitation_handler(query: CallbackQuery, state: FSMContext):
    id = query.data.split(".")[2]

    print(id)

    exploitation_item = await exploitation_items_controller.get_one({"_id": ObjectId(id)})

    print(exploitation_item)

    product = await product_controller.get_one({"name": exploitation_item['product_name']})

    print(product)

    if exploitation_item['quantity'] + 1 > product['not_in_use']:
        await query.message.answer(
            text=f"На складе нет {exploitation_item['quantity'] + 1} {exploitation_item['product_name']} данного типа"
        )

        return

    exploitation = await exploitation_controller.get_one({"status": 'process'})

    await exploitation_items_controller.increment({"_id": exploitation_item['_id']}, {"quantity": 1})

    exploitation_items = await exploitation_items_controller.get_all(
        {"exploitation_id": exploitation['_id'], "status": "added"}
    )

    await query.message.edit_text(
        text=confirmation_exploitation_format(exploitation, exploitation_items),
        reply_markup=confirmation_exploitation_keyboard(exploitation_items)
    )


@dp.callback_query_handler(lambda query: query.data == "cancel.exploitation", state=ExploitationStates.process)
async def get_name_for_confirm_exploitation_handler(query: CallbackQuery, state: FSMContext):
    exploitation = await exploitation_controller.get_one({"status": "process"})

    await exploitation_items_controller.delete_many({"exploitation_id": exploitation['_id'], "status": "added"})

    await exploitation_controller.delete({"_id": exploitation['_id']})

    await query.message.edit_text(
        text="Сервис был отключен, потому что больше нечего было давать",
        reply_markup=exploitation_keyboard()
    )


@dp.callback_query_handler(lambda query: query.data == "confirm.exploitation", state=ExploitationStates.process)
async def get_name_for_confirm_exploitation_handler(query: CallbackQuery, state: FSMContext):
    acquired_techniques = []

    exploitation = await exploitation_controller.get_one({"status": "process"})

    exploitation_items = await exploitation_items_controller.get_all(
        {"exploitation_id": exploitation['_id'], "status": "added"}
    )

    for products in exploitation_items:
        product = await product_controller.get_one({"name": products['product_name']})
        if product['not_in_use'] < products['quantity']:
            acquired_techniques.append(products)

    if len(acquired_techniques) > 0:
        await query.answer()

        for technique in acquired_techniques:
            await query.message.answer(text=f"На складе больше нет {technique['quantity']} {technique['product_name']}")
        return

    await ExploitationStates.bein_given.set()

    message_id_for_delete = (await state.get_data())['message_for_delete']

    await query.message.answer("Кому даёте")

    await bot.delete_message(chat_id=query.from_user.id, message_id=message_id_for_delete)


@dp.message_handler(state=ExploitationStates.bein_given)
async def confirm_exploitation_handler(message: Message, state: FSMContext):
    if is_num(message.text):
        await message.answer(text="Отправьте правильное имя а не число")
        return

    exploitation = await exploitation_controller.get_one({"status": "process"})

    for products in exploitation['products']:
        exploitation_item = await exploitation_items_controller.get_one({"_id": ObjectId(products), "status": "added"})

        await product_controller.increment(
            {"name": exploitation_item['product_name']},
            {"in_use": exploitation_item['quantity'], "not_in_use": -exploitation_item['quantity']}
        )

    await exploitation_items_controller.update_many(
        query={"exploitation_id": exploitation['_id'], "status": "added"},
        data={"being_given": message.text, "given_at": datetime.now(), "status": "using"}
    )

    await exploitation_controller.update(
        {"_id": exploitation['_id']},
        {"being_given": message.text, "status": "using", "given_at": datetime.now()}
    )


    # exploitation['bein_given'] = message.text
    # exploitation['status'] = "using"
    # exploitation['given_at'] = datetime.now()
    # await exploitation.save()

    message_text = "Техники дано к эксплуатацию. Вы можете увидеть это в странице <b>Используемые</b>"

    await message.delete()

    await ExploitationStates.process.set()

    message_for_delete = await message.answer(text=message_text, reply_markup=exploitation_keyboard())

    async with state.proxy() as data:
        data['message_for_delete'] = message_for_delete.message_id


@dp.callback_query_handler(lambda query: query.data == "used_products", state=ExploitationStates.process)
async def used_exploitation_products_handler(query: CallbackQuery, state: FSMContext):
    pagination = Pagination(data_type="EXPLOITATIONS")
    paginated = await pagination.paginate(query=dict(status="returned"), page=1, limit=6)
    await ExploitationStates.all_used_exploitations.set()
    await query.message.edit_text(text=paginated['message'], reply_markup=paginated['keyboard'])


@dp.callback_query_handler(lambda query: query.data == "back", state=ExploitationStates.all_used_exploitations)
async def back_from_exploitation_all_used_products_handler(query: CallbackQuery, state: FSMContext):
    await ExploitationStates.process.set()
    await query.message.edit_text(text="Страница эксплуатации", reply_markup=exploitation_keyboard())


@dp.callback_query_handler(lambda query: query.data == "delete", state=ExploitationStates.all_used_exploitations)
async def back_from_exploitation_all_used_products_handler(query: CallbackQuery, state: FSMContext):
    await ExploitationStates.process.set()
    await query.message.edit_text(text="Страница эксплуатации", reply_markup=exploitation_keyboard())


@dp.callback_query_handler(
    lambda query: query.data in ["left#used_exploitation#", "right#used_exploitation#"],
    state=ExploitationStates.all_used_exploitations
)
async def pagination_exploitation_used_products_handler(query: CallbackQuery, state: FSMContext):
    pagination = Pagination(data_type="PRODUCTS")
    paginated = await pagination.paginate(query=dict(status="returned"), page=int(query.data.split("#")[2]), limit=6)
    await query.message.edit_text(text=paginated['message'], reply_markup=paginated['keyboard'])


@dp.callback_query_handler(lambda query: query.data.startswith("sel.expo_"), state=ExploitationStates.all_used_exploitations)
async def get_used_exploitation_handler(query: CallbackQuery, state: FSMContext):
    id, products = query.data.split("_")[1], []

    exploitation = await exploitation_controller.get_one({"_id": ObjectId(id)})

    for product in exploitation['products']:
        exploitation_item = await exploitation_items_controller.get_one({"_id": ObjectId(product)})
        products.append(exploitation_item)

    await ExploitationStates.one_used_exploitation.set()

    await query.message.edit_text(
        text=exploitation_format(exploitation, products),
        reply_markup=back_keyboard())


@dp.callback_query_handler(lambda query: query.data == "back", state=ExploitationStates.one_used_exploitation)
async def back_from_exploitation_get_used_product_handler(query: CallbackQuery, state: FSMContext):
    pagination = Pagination(data_type="EXPLOITATIONS")
    paginated = await pagination.paginate(query=dict(status="returned"), page=1, limit=6)
    await ExploitationStates.all_used_exploitations.set()
    await query.message.edit_text(text=paginated['message'], reply_markup=paginated['keyboard'])


@dp.callback_query_handler(lambda query: query.data == "using_products", state=ExploitationStates.process)
async def exploitation_using_products_handler(query: CallbackQuery, state: FSMContext):
    pagination = Pagination(data_type="EXPLOITATIONS")
    paginated = await pagination.paginate(query=dict(status="using"), page=1, limit=6)
    await ExploitationStates.all_using_exploitations.set()
    await query.message.edit_text(text=paginated['message'], reply_markup=paginated['keyboard'])


@dp.callback_query_handler(lambda query: query.data == "back", state=ExploitationStates.all_using_exploitations)
async def back_from_all_products_handler(query: CallbackQuery, state: FSMContext):
    await ExploitationStates.process.set()
    await query.message.edit_text(text="Страница эксплуатации", reply_markup=exploitation_keyboard())


@dp.callback_query_handler(lambda query: query.data == "delete", state=ExploitationStates.all_using_exploitations)
async def back_from_exploitation_all_using_products_handler(query: CallbackQuery, state: FSMContext):
    await ExploitationStates.process.set()
    await query.message.edit_text(text="Страница эксплуатации", reply_markup=exploitation_keyboard())


@dp.callback_query_handler(
    lambda query: query.data in ["left#using_exploitation#", "right#using_exploitation#"],
    state=ExploitationStates.all_using_exploitations
)
async def pagination_exploitation_using_products_handler(query: CallbackQuery, state: FSMContext):
    pagination = Pagination(data_type="PRODUCTS")
    paginated = await pagination.paginate(query=dict(status='using'), page=int(query.data.split("#")[2]), limit=6)
    await query.message.edit_text(text=paginated['message'], reply_markup=paginated['keyboard'])


@dp.callback_query_handler(lambda query: query.data.startswith("sel.expo_"), state=ExploitationStates.all_using_exploitations)
async def get_exploitation_using_product_handler(query: CallbackQuery, state: FSMContext):
    id, products = query.data.split("_")[1], []

    exploitation = await exploitation_controller.get_one({"_id": ObjectId(id)})

    for product in exploitation['products']:
        exploitation_item = await exploitation_items_controller.get_one({"_id": ObjectId(product)})
        products.append(exploitation_item)

    await ExploitationStates.one_using_exploitation.set()

    await query.message.edit_text(text=exploitation_format(exploitation, products), reply_markup=one_using_exploitation_keyboard(id))


@dp.callback_query_handler(lambda query: query.data.startswith("return.exploitation."), state=ExploitationStates.one_using_exploitation)
async def return_exploitation_handler(query: CallbackQuery, state: FSMContext):
    id = query.data.split(".")[2]

    exploitation = await exploitation_controller.get_one({"_id": ObjectId(id)})

    for product in exploitation['products']:
        exploitation_item = await exploitation_items_controller.get_one({"_id": ObjectId(product)})

        await product_controller.increment(
            {"name": exploitation_item['product_name']},
            {"in_use": -exploitation_item['quantity'], "not_in_use": exploitation_item['quantity']}
        )
        await exploitation_items_controller.update(
            {"_id": ObjectId(product)}, {"status": "returned", "returned_at": datetime.now()}
        )

    await exploitation_controller.update(
        {"_id": exploitation['_id']},
        {"status": "returned", "returned_at": datetime.now()}
    )

    # await exploitation_items_controller.update_many(
    #     {"exploitation_id": exploitation['_id'], "status": "using"},
    #     {"status": "returned"}
    # )

    # exploitation['returned_at'] = datetime.now()
    # exploitation['status'] = "returned"
    # await exploitation.save()

    pagination = Pagination(data_type="PRODUCTS")
    paginated = await pagination.paginate(query=dict(status="using"), page=1, limit=6)
    await ExploitationStates.all_using_exploitations.set()
    await query.message.edit_text(text=paginated['message'], reply_markup=paginated['keyboard'])


@dp.callback_query_handler(lambda query: query.data == "back", state=ExploitationStates.one_using_exploitation)
async def back_from_get_product_handler(query: CallbackQuery, state: FSMContext):
    pagination = Pagination(data_type="EXPLOITATIONS")
    paginated = await pagination.paginate(query=dict(status="using"), page=1, limit=6)
    await ExploitationStates.all_used_exploitations.set()
    await query.message.edit_text(text=paginated['message'], reply_markup=paginated['keyboard'])
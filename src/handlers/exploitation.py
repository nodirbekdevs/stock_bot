from datetime import datetime

from aiogram.dispatcher import FSMContext
from aiogram.types import CallbackQuery, Message
from bson import ObjectId

from src.loader import dp, bot
from src.models import Admin, Product, Exploitation, ExploitationItem
from src.controllers import admin_controller, product_controller, exploitation_controller, exploitation_items_controller
from src.helpers.keyboards import (
    exploitation_keyboard,
    back_keyboard,
    one_exploitation_product_keyboard,
    confirmation_exploitation_keyboard,
    one_using_exploitation_keyboard
)
from src.helpers.utils import Pagination, is_num
from src.helpers.format import product_format, exploitation_format, confirmation_exploitation_format
from src.states.exploitation import ExploitationStates


@dp.callback_query_handler(lambda query: query.data == "products", state=ExploitationStates.process)
async def exploitation_all_products_handler(query: CallbackQuery, state: FSMContext):
    pagination = Pagination(data_type="PRODUCTS")
    paginated = await pagination.paginate(query={}, page=1, limit=6)
    await ExploitationStates.all_products.set()
    await query.message.edit_text(text=paginated['message'], reply_markup=paginated['keyboard'])


@dp.callback_query_handler(lambda query: query.data == "back", state=ExploitationStates.all_products)
async def back_from_exploitation_all_products_handler(query: CallbackQuery, state: FSMContext):
    await ExploitationStates.process.set()
    await query.message.edit_text(text="Страница эксплуатации", reply_markup=exploitation_keyboard())


@dp.callback_query_handler(lambda query: query.data == "delete", state=ExploitationStates.all_products)
async def back_from_exploitation_all_products_handler(query: CallbackQuery, state: FSMContext):
    await ExploitationStates.process.set()
    await query.message.edit_text(text="Страница эксплуатации", reply_markup=exploitation_keyboard())


@dp.callback_query_handler(lambda query: query.data in ["left#products#", "right#products#"],
                           state=ExploitationStates.all_products)
async def pagination_exploitation_products_handler(query: CallbackQuery, state: FSMContext):
    pagination = Pagination(data_type="PRODUCTS")
    paginated = await pagination.paginate(query={}, page=int(query.data.split("#")[2]), limit=6)
    await query.message.edit_text(text=paginated['message'], reply_markup=paginated['keyboard'])


@dp.callback_query_handler(lambda query: query.data.startswith("sproduct_"), state=ExploitationStates.all_products)
async def get_exploitation_product_handler(query: CallbackQuery, state: FSMContext):
    id = query.data.split("_")[1]

    exploitation = await exploitation_controller.get_one({"admin": query.from_user.id, "status": "process"})

    product = await product_controller.get_one({"_id": ObjectId(id)})

    if exploitation:
        await query.answer()

        exploitation_item = await exploitation_items_controller.get_one({
            "exploitation_id": exploitation['_id'],
            "admin": query.from_user.id,
            "product_name": product['name'],
            "status": "added"

        })

        if exploitation_item and exploitation_item['_id'] in exploitation['products']:
            await query.answer()

            await query.message.answer(
                "Эта техника была взята вами для эксплуатации перейдите в страницу <b>Подтверждение</b>, чтобы увидеть"
            )
            return

    if product['count'] == product['in_use'] and product['not_in_use'] == 0:
        await query.answer()

        await query.message.answer(f"Весь этот тип {product['name']} был взят для использования")
        return

    await ExploitationStates.one_product.set()

    await query.message.edit_text(text=product_format(product), reply_markup=one_exploitation_product_keyboard(id))


@dp.callback_query_handler(lambda query: query.data == "back", state=ExploitationStates.one_product)
async def back_from_get_product_handler(query: CallbackQuery, state: FSMContext):
    pagination = Pagination(data_type="PRODUCTS")
    paginated = await pagination.paginate(query={}, page=1, limit=6)
    await ExploitationStates.all_products.set()
    await query.message.edit_text(text=paginated['message'], reply_markup=paginated['keyboard'])


@dp.callback_query_handler(lambda query: query.data.startswith("add_use.product."),
                           state=ExploitationStates.one_product)
async def set_exploitation_product_handler(query: CallbackQuery, state: FSMContext):
    id = query.data.split(".")[2]

    admin: Admin = await admin_controller.get_one({"admin_id": query.from_user.id})

    exploitation: Exploitation = await exploitation_controller.get_one(
        {"admin": query.from_user.id, "status": "process"}
    )

    if exploitation is None:
        new_exploitation = await exploitation_controller.make({"admin": admin['admin_id']})
        exploitation: Exploitation = await exploitation_controller.get_one({"_id": new_exploitation.inserted_id})

    product: Product = await product_controller.get_one({"_id": ObjectId(id)})

    if product['_id'] in exploitation['products']:
        await query.message.answer(text="Вы уже добавили эту технику для начинания эксплуатации")
        return

    data = dict(exploitation_id=exploitation['_id'], admin=admin['admin_id'], product_name=product['name'])

    exploitation_item_id = await exploitation_items_controller.make(data)

    await exploitation_controller.update_append_list(
        {"_id": exploitation['_id']},
        {"products": exploitation_item_id.inserted_id}
    )

    await ExploitationStates.items.set()

    await query.message.edit_text(text=f"Сколько {product['name']} берется в пользование")


@dp.message_handler(state=ExploitationStates.items)
async def set_product_number_of_exploitation_handler(message: Message, state: FSMContext):
    quantity = message.text

    if not is_num(quantity):
        await message.answer(text="Отправьте правильный число")
        return

    message_id_for_delete = (await state.get_data())[f'message_for_delete_{message.from_user.id}']

    exploitation = await exploitation_controller.get_one({"admin": message.from_user.id, "status": "process"})

    item: ExploitationItem = await exploitation_items_controller.get_one({"status": "process"})

    product: Product = await product_controller.get_one({"name": item['product_name']})

    if product['count'] < int(quantity) or product['not_in_use'] < int(quantity):
        await message.answer(text=f"{quantity} {product['name']} недоступны для использования на складе")
        return

    await exploitation_items_controller.update(
        {"exploitation_id": exploitation['_id'], "product_name": product['name'], "status": "process"},
        {"quantity": int(quantity), "status": "added"}
    )

    await message.delete()
    await bot.delete_message(chat_id=message.from_user.id, message_id=message_id_for_delete)

    await ExploitationStates.process.set()

    message_for_delete = await message.answer("Техника добавлено для использовании",
                                              reply_markup=exploitation_keyboard())

    async with state.proxy() as data:
        data[f'message_for_delete_{message.from_user.id}'] = message_for_delete.message_id


@dp.callback_query_handler(lambda query: query.data == "confirmation_products", state=ExploitationStates.process)
async def confirm_exploitation_handler(query: CallbackQuery, state: FSMContext):
    exploitation = await exploitation_controller.get_one({"admin": query.from_user.id, "status": 'process'})

    if exploitation is None:
        await query.message.edit_text(
            text="Ничего не было добавлено, чтобы дать еще",
            reply_markup=exploitation_keyboard()
        )
        return

    exploitation_items = await exploitation_items_controller.get_all(
        {"exploitation_id": exploitation['_id'], "status": "added"}
    )

    await query.message.edit_text(
        text=confirmation_exploitation_format(exploitation, exploitation_items),
        reply_markup=confirmation_exploitation_keyboard(exploitation_items)
    )


@dp.callback_query_handler(lambda query: query.data.startswith("minus.product."), state=ExploitationStates.process)
async def minus_exploitation_product_handler(query: CallbackQuery, state: FSMContext):
    id = query.data.split(".")[2]

    exploitation_item = await exploitation_items_controller.get_one({"_id": ObjectId(id)})

    if exploitation_item['quantity'] - 1 == 0:
        await exploitation_controller.update_remove_list(
            {"status": "process"},
            {"products": exploitation_item['_id']}
        )

        await exploitation_items_controller.delete({"_id": exploitation_item['_id']})

    exploitation = await exploitation_controller.get_one({"admin": query.from_user.id, "status": 'process'})

    if len(exploitation['products']) == 0:
        await exploitation_controller.delete({"_id": exploitation['_id']})

        await query.message.edit_text(
            text="Сервис был отключен, потому что больше нечего было давать",
            reply_markup=exploitation_keyboard()
        )
        return

    await exploitation_items_controller.increment({"_id": exploitation_item['_id']}, {"quantity": -1})

    exploitation_items = await exploitation_items_controller.get_all(
        {"exploitation_id": exploitation['_id'], "status": "added"}
    )

    await query.message.edit_text(
        text=confirmation_exploitation_format(exploitation, exploitation_items),
        reply_markup=confirmation_exploitation_keyboard(exploitation_items)
    )


@dp.callback_query_handler(lambda query: query.data.startswith("delete.exp_product."), state=ExploitationStates.process)
async def delete_exploitation_product_handler(query: CallbackQuery, state: FSMContext):
    id = query.data.split(".")[2]

    exploitation_item = await exploitation_items_controller.get_one({"_id": ObjectId(id)})

    await exploitation_controller.update_remove_list(
        {"status": "process"},
        {"products": exploitation_item['_id']}
    )

    await exploitation_items_controller.delete({"_id": exploitation_item['_id']})

    exploitation = await exploitation_controller.get_one({"admin": query.from_user.id, "status": 'process'})

    if len(exploitation['products']) == 0:
        await exploitation_controller.delete({"_id": exploitation['_id']})

        await query.message.edit_text(
            text="Сервис был отключен, потому что больше нечего было давать",
            reply_markup=exploitation_keyboard()
        )
        return

    exploitation_items = await exploitation_items_controller.get_all(
        {"exploitation_id": exploitation['_id'], "status": "added"}
    )

    await query.message.edit_text(
        text=confirmation_exploitation_format(exploitation, exploitation_items),
        reply_markup=confirmation_exploitation_keyboard(exploitation_items)
    )


@dp.callback_query_handler(lambda query: query.data.startswith("plus.product."), state=ExploitationStates.process)
async def plus_exploitation_product_handler(query: CallbackQuery, state: FSMContext):
    id = query.data.split(".")[2]
    exploitation_item = await exploitation_items_controller.get_one({"_id": ObjectId(id)})

    product = await product_controller.get_one({"name": exploitation_item['product_name']})

    if exploitation_item['quantity'] + 1 > product['not_in_use']:
        await query.message.answer(
            text=f"На складе нет {exploitation_item['quantity'] + 1} {exploitation_item['product_name']} данного типа"
        )
        return

    exploitation = await exploitation_controller.get_one({"admin": query.from_user.id, "status": 'process'})

    await exploitation_items_controller.increment({"_id": exploitation_item['_id']}, {"quantity": 1})

    exploitation_items = await exploitation_items_controller.get_all(
        {"exploitation_id": exploitation['_id'], "status": "added"}
    )

    await query.message.edit_text(
        text=confirmation_exploitation_format(exploitation, exploitation_items),
        reply_markup=confirmation_exploitation_keyboard(exploitation_items)
    )


@dp.callback_query_handler(lambda query: query.data == "cancel.exploitation", state=ExploitationStates.process)
async def cancel_exploitation_handler(query: CallbackQuery, state: FSMContext):
    exploitation = await exploitation_controller.get_one({"admin": query.from_user.id, "status": "process"})

    await exploitation_items_controller.delete_many({"exploitation_id": exploitation['_id'], "status": "added"})

    await exploitation_controller.delete({"_id": exploitation['_id']})

    await query.message.edit_text(
        text="Сервис был отключен, потому что больше нечего было давать",
        reply_markup=exploitation_keyboard()
    )


@dp.callback_query_handler(lambda query: query.data == "confirm.exploitation", state=ExploitationStates.process)
async def get_name_for_confirm_exploitation_handler(query: CallbackQuery, state: FSMContext):
    info = ""

    exploitation = await exploitation_controller.get_one({"admin": query.from_user.id, "status": "process"})

    exploitation_items = await exploitation_items_controller.get_all(
        {"exploitation_id": exploitation['_id'], "status": "added"}
    )

    for products in exploitation_items:
        product = await product_controller.get_one({"name": products['product_name']})

        if product['not_in_use'] < products['quantity']:
            info += f"На складе осталось {product['not_in_use']} {product['name']}\n"

    if info:
        await query.message.answer(info)
        return

    # if len(acquired_techniques) > 0:
    #     await query.answer()
    #     info = ""
    #     for technique in acquired_techniques:
    #         info += f"На складе больше нет {technique['quantity']} {technique['product_name']}"
    #     await query.message.answer(text=info)
    #     return

    await ExploitationStates.bein_given.set()

    message_id_for_delete = (await state.get_data())[f'message_for_delete_{query.from_user.id}']

    await query.message.answer("Кому даёте")

    await bot.delete_message(chat_id=query.from_user.id, message_id=message_id_for_delete)


@dp.message_handler(state=ExploitationStates.bein_given)
async def confirm_exploitation_handler(message: Message, state: FSMContext):
    if is_num(message.text):
        await message.answer(text="Отправьте правильное имя а не число")
        return

    exploitation = await exploitation_controller.get_one({"admin": message.from_user.id, "status": "process"})

    for products in exploitation['products']:
        exploitation_item = await exploitation_items_controller.get_one({
            "_id": ObjectId(products),
            "exploitation_id": exploitation['_id'],
            "status": "added"
        })

        await product_controller.increment(
            {"name": exploitation_item['product_name']},
            {"in_use": exploitation_item['quantity'], "not_in_use": -exploitation_item['quantity']}
        )

    await exploitation_items_controller.update_many(
        query={"exploitation_id": exploitation['_id'], "status": "added"},
        data={"being_given": message.text, "given_at": datetime.now(), "status": "using"}
    )

    await exploitation_controller.update(
        {"_id": exploitation['_id']},
        {"being_given": message.text, "status": "using", "given_at": datetime.now()}
    )

    message_text = "Техники дано к эксплуатацию. Вы можете увидеть это в странице <b>Используемые</b>"

    await message.delete()

    await ExploitationStates.process.set()

    message_for_delete = await message.answer(text=message_text, reply_markup=exploitation_keyboard())

    async with state.proxy() as data:
        data[f'message_for_delete_{message.from_user.id}'] = message_for_delete.message_id


@dp.callback_query_handler(lambda query: query.data == "used_products", state=ExploitationStates.process)
async def used_exploitation_products_handler(query: CallbackQuery, state: FSMContext):
    pagination = Pagination(data_type="EXPLOITATIONS")
    paginated = await pagination.paginate(query=dict(status="returned"), page=1, limit=6)
    await ExploitationStates.all_used_exploitations.set()
    await query.message.edit_text(text=paginated['message'], reply_markup=paginated['keyboard'])


@dp.callback_query_handler(lambda query: query.data == "back", state=ExploitationStates.all_used_exploitations)
async def back_from_all_used_exploitations_handler(query: CallbackQuery, state: FSMContext):
    await ExploitationStates.process.set()
    await query.message.edit_text(text="Страница эксплуатации", reply_markup=exploitation_keyboard())


@dp.callback_query_handler(lambda query: query.data == "delete", state=ExploitationStates.all_used_exploitations)
async def back_from_all_used_exploitations_handler(query: CallbackQuery, state: FSMContext):
    await ExploitationStates.process.set()
    await query.message.edit_text(text="Страница эксплуатации", reply_markup=exploitation_keyboard())


@dp.callback_query_handler(
    lambda query: query.data in ["left#used_exploitation#", "right#used_exploitation#"],
    state=ExploitationStates.all_used_exploitations
)
async def pagination_all_used_exploitations_handler(query: CallbackQuery, state: FSMContext):
    pagination = Pagination(data_type="EXPLOITATIONS")
    paginated = await pagination.paginate(query=dict(status="returned"), page=int(query.data.split("#")[2]), limit=6)
    await query.message.edit_text(text=paginated['message'], reply_markup=paginated['keyboard'])


@dp.callback_query_handler(lambda query: query.data.startswith("sel.expo_"),
                           state=ExploitationStates.all_used_exploitations)
async def get_used_exploitation_handler(query: CallbackQuery, state: FSMContext):
    id, products = query.data.split("_")[1], []

    admin_name = (await admin_controller.get_one({"admin_id": query.from_user.id}))['first_name']

    exploitation = await exploitation_controller.get_one({"_id": ObjectId(id)})

    for product in exploitation['products']:
        exploitation_item = await exploitation_items_controller.get_one({"_id": ObjectId(product)})
        products.append(exploitation_item)

    await ExploitationStates.one_used_exploitation.set()

    await query.message.edit_text(
        text=exploitation_format(exploitation, admin_name, products),
        reply_markup=back_keyboard()
    )


@dp.callback_query_handler(lambda query: query.data == "back", state=ExploitationStates.one_used_exploitation)
async def back_from_exploitation_get_used_product_handler(query: CallbackQuery, state: FSMContext):
    pagination = Pagination(data_type="EXPLOITATIONS")
    paginated = await pagination.paginate(query=dict(status="returned"), page=1, limit=6)
    await ExploitationStates.all_used_exploitations.set()
    await query.message.edit_text(text=paginated['message'], reply_markup=paginated['keyboard'])


@dp.callback_query_handler(lambda query: query.data == "using_products", state=ExploitationStates.process)
async def get_using_exploitation_handler(query: CallbackQuery, state: FSMContext):
    pagination = Pagination(data_type="EXPLOITATIONS")
    paginated = await pagination.paginate(query=dict(status="using"), page=1, limit=6)
    await ExploitationStates.all_using_exploitations.set()
    await query.message.edit_text(text=paginated['message'], reply_markup=paginated['keyboard'])


@dp.callback_query_handler(lambda query: query.data == "back", state=ExploitationStates.all_using_exploitations)
async def back_from_all_using_exploitation_handler(query: CallbackQuery, state: FSMContext):
    await ExploitationStates.process.set()
    await query.message.edit_text(text="Страница эксплуатации", reply_markup=exploitation_keyboard())


@dp.callback_query_handler(lambda query: query.data == "delete", state=ExploitationStates.all_using_exploitations)
async def back_from_exploitation_all_using_products_handler(query: CallbackQuery, state: FSMContext):
    await ExploitationStates.process.set()
    await query.message.edit_text(text="Страница эксплуатации", reply_markup=exploitation_keyboard())


@dp.callback_query_handler(
    lambda query: query.data in ["left#using_exploitation#", "right#using_exploitation#"],
    state=ExploitationStates.all_using_exploitations
)
async def pagination_exploitation_using_products_handler(query: CallbackQuery, state: FSMContext):
    pagination = Pagination(data_type="EXPLOITATIONS")
    paginated = await pagination.paginate(query=dict(status='using'), page=int(query.data.split("#")[2]), limit=6)
    await query.message.edit_text(text=paginated['message'], reply_markup=paginated['keyboard'])


@dp.callback_query_handler(lambda query: query.data.startswith("sel.expo_"),
                           state=ExploitationStates.all_using_exploitations)
async def get_exploitation_using_exploitation_handler(query: CallbackQuery, state: FSMContext):
    id, products = query.data.split("_")[1], []

    admin_name = (await admin_controller.get_one({"admin_id": query.from_user.id}))['first_name']

    exploitation = await exploitation_controller.get_one({"_id": ObjectId(id)})

    for product in exploitation['products']:
        exploitation_item = await exploitation_items_controller.get_one({"_id": ObjectId(product)})
        products.append(exploitation_item)

    await ExploitationStates.one_using_exploitation.set()

    await query.message.edit_text(text=exploitation_format(exploitation, admin_name, products),
                                  reply_markup=one_using_exploitation_keyboard(id))


@dp.callback_query_handler(lambda query: query.data.startswith("return.exploitation."),
                           state=ExploitationStates.one_using_exploitation)
async def return_exploitation_handler(query: CallbackQuery, state: FSMContext):
    id = query.data.split(".")[2]

    exploitation = await exploitation_controller.get_one({"_id": ObjectId(id)})

    for product in exploitation['products']:
        exploitation_item = await exploitation_items_controller.get_one({"_id": ObjectId(product)})

        await product_controller.increment(
            {"name": exploitation_item['product_name']},
            {"in_use": -exploitation_item['quantity'], "not_in_use": exploitation_item['quantity']}
        )
        await exploitation_items_controller.update(
            {"_id": ObjectId(product)}, {"status": "returned", "returned_at": datetime.now()}
        )

    await exploitation_controller.update(
        {"_id": exploitation['_id']},
        {"status": "returned", "returned_at": datetime.now()}
    )

    pagination = Pagination(data_type="EXPLOITATIONS")
    paginated = await pagination.paginate(query=dict(status="using"), page=1, limit=6)
    await ExploitationStates.all_using_exploitations.set()
    await query.message.edit_text(text=paginated['message'], reply_markup=paginated['keyboard'])


@dp.callback_query_handler(lambda query: query.data == "back", state=ExploitationStates.one_using_exploitation)
async def back_from_get_using_exploitation_handler(query: CallbackQuery, state: FSMContext):
    pagination = Pagination(data_type="EXPLOITATIONS")
    paginated = await pagination.paginate(query=dict(status="using"), page=1, limit=6)
    await ExploitationStates.all_used_exploitations.set()
    await query.message.edit_text(text=paginated['message'], reply_markup=paginated['keyboard'])
